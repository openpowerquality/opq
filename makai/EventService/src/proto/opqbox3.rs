// This file is generated by rust-protobuf 2.8.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `opqbox3.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_0;

#[derive(PartialEq,Clone,Default)]
pub struct Metric {
    // message fields
    pub min: f32,
    pub max: f32,
    pub average: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Metric {
    fn default() -> &'a Metric {
        <Metric as ::protobuf::Message>::default_instance()
    }
}

impl Metric {
    pub fn new() -> Metric {
        ::std::default::Default::default()
    }

    // float min = 1;


    pub fn get_min(&self) -> f32 {
        self.min
    }
    pub fn clear_min(&mut self) {
        self.min = 0.;
    }

    // Param is passed by value, moved
    pub fn set_min(&mut self, v: f32) {
        self.min = v;
    }

    // float max = 2;


    pub fn get_max(&self) -> f32 {
        self.max
    }
    pub fn clear_max(&mut self) {
        self.max = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: f32) {
        self.max = v;
    }

    // float average = 3;


    pub fn get_average(&self) -> f32 {
        self.average
    }
    pub fn clear_average(&mut self) {
        self.average = 0.;
    }

    // Param is passed by value, moved
    pub fn set_average(&mut self, v: f32) {
        self.average = v;
    }
}

impl ::protobuf::Message for Metric {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.min = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.max = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.average = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.min != 0. {
            my_size += 5;
        }
        if self.max != 0. {
            my_size += 5;
        }
        if self.average != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.min != 0. {
            os.write_float(1, self.min)?;
        }
        if self.max != 0. {
            os.write_float(2, self.max)?;
        }
        if self.average != 0. {
            os.write_float(3, self.average)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Metric {
        Metric::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "min",
                    |m: &Metric| { &m.min },
                    |m: &mut Metric| { &mut m.min },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "max",
                    |m: &Metric| { &m.max },
                    |m: &mut Metric| { &mut m.max },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "average",
                    |m: &Metric| { &m.average },
                    |m: &mut Metric| { &mut m.average },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Metric>(
                    "Metric",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Metric {
        static mut instance: ::protobuf::lazy::Lazy<Metric> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Metric,
        };
        unsafe {
            instance.get(Metric::new)
        }
    }
}

impl ::protobuf::Clear for Metric {
    fn clear(&mut self) {
        self.min = 0.;
        self.max = 0.;
        self.average = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Metric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Metric {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Measurement {
    // message fields
    pub box_id: u32,
    pub timestamp_ms: u64,
    pub metrics: ::std::collections::HashMap<::std::string::String, Metric>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Measurement {
    fn default() -> &'a Measurement {
        <Measurement as ::protobuf::Message>::default_instance()
    }
}

impl Measurement {
    pub fn new() -> Measurement {
        ::std::default::Default::default()
    }

    // uint32 box_id = 1;


    pub fn get_box_id(&self) -> u32 {
        self.box_id
    }
    pub fn clear_box_id(&mut self) {
        self.box_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_box_id(&mut self, v: u32) {
        self.box_id = v;
    }

    // uint64 timestamp_ms = 2;


    pub fn get_timestamp_ms(&self) -> u64 {
        self.timestamp_ms
    }
    pub fn clear_timestamp_ms(&mut self) {
        self.timestamp_ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp_ms(&mut self, v: u64) {
        self.timestamp_ms = v;
    }

    // repeated .opq.opqbox3.Measurement.MetricsEntry metrics = 3;


    pub fn get_metrics(&self) -> &::std::collections::HashMap<::std::string::String, Metric> {
        &self.metrics
    }
    pub fn clear_metrics(&mut self) {
        self.metrics.clear();
    }

    // Param is passed by value, moved
    pub fn set_metrics(&mut self, v: ::std::collections::HashMap<::std::string::String, Metric>) {
        self.metrics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metrics(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, Metric> {
        &mut self.metrics
    }

    // Take field
    pub fn take_metrics(&mut self) -> ::std::collections::HashMap<::std::string::String, Metric> {
        ::std::mem::replace(&mut self.metrics, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Measurement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.box_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp_ms = tmp;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Metric>>(wire_type, is, &mut self.metrics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.box_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.box_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp_ms != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timestamp_ms, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Metric>>(3, &self.metrics);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.box_id != 0 {
            os.write_uint32(1, self.box_id)?;
        }
        if self.timestamp_ms != 0 {
            os.write_uint64(2, self.timestamp_ms)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Metric>>(3, &self.metrics, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Measurement {
        Measurement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "box_id",
                    |m: &Measurement| { &m.box_id },
                    |m: &mut Measurement| { &mut m.box_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timestamp_ms",
                    |m: &Measurement| { &m.timestamp_ms },
                    |m: &mut Measurement| { &mut m.timestamp_ms },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Metric>>(
                    "metrics",
                    |m: &Measurement| { &m.metrics },
                    |m: &mut Measurement| { &mut m.metrics },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Measurement>(
                    "Measurement",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Measurement {
        static mut instance: ::protobuf::lazy::Lazy<Measurement> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Measurement,
        };
        unsafe {
            instance.get(Measurement::new)
        }
    }
}

impl ::protobuf::Clear for Measurement {
    fn clear(&mut self) {
        self.box_id = 0;
        self.timestamp_ms = 0;
        self.metrics.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Measurement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Measurement {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInfoCommand {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInfoCommand {
    fn default() -> &'a GetInfoCommand {
        <GetInfoCommand as ::protobuf::Message>::default_instance()
    }
}

impl GetInfoCommand {
    pub fn new() -> GetInfoCommand {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetInfoCommand {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInfoCommand {
        GetInfoCommand::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetInfoCommand>(
                    "GetInfoCommand",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetInfoCommand {
        static mut instance: ::protobuf::lazy::Lazy<GetInfoCommand> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetInfoCommand,
        };
        unsafe {
            instance.get(GetInfoCommand::new)
        }
    }
}

impl ::protobuf::Clear for GetInfoCommand {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInfoCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInfoCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDataCommand {
    // message fields
    pub start_ms: u64,
    pub end_ms: u64,
    pub wait: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDataCommand {
    fn default() -> &'a GetDataCommand {
        <GetDataCommand as ::protobuf::Message>::default_instance()
    }
}

impl GetDataCommand {
    pub fn new() -> GetDataCommand {
        ::std::default::Default::default()
    }

    // uint64 start_ms = 1;


    pub fn get_start_ms(&self) -> u64 {
        self.start_ms
    }
    pub fn clear_start_ms(&mut self) {
        self.start_ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_ms(&mut self, v: u64) {
        self.start_ms = v;
    }

    // uint64 end_ms = 2;


    pub fn get_end_ms(&self) -> u64 {
        self.end_ms
    }
    pub fn clear_end_ms(&mut self) {
        self.end_ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_ms(&mut self, v: u64) {
        self.end_ms = v;
    }

    // bool wait = 3;


    pub fn get_wait(&self) -> bool {
        self.wait
    }
    pub fn clear_wait(&mut self) {
        self.wait = false;
    }

    // Param is passed by value, moved
    pub fn set_wait(&mut self, v: bool) {
        self.wait = v;
    }
}

impl ::protobuf::Message for GetDataCommand {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_ms = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.end_ms = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.wait = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_ms != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_ms, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_ms != 0 {
            my_size += ::protobuf::rt::value_size(2, self.end_ms, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.wait != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.start_ms != 0 {
            os.write_uint64(1, self.start_ms)?;
        }
        if self.end_ms != 0 {
            os.write_uint64(2, self.end_ms)?;
        }
        if self.wait != false {
            os.write_bool(3, self.wait)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDataCommand {
        GetDataCommand::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "start_ms",
                    |m: &GetDataCommand| { &m.start_ms },
                    |m: &mut GetDataCommand| { &mut m.start_ms },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "end_ms",
                    |m: &GetDataCommand| { &m.end_ms },
                    |m: &mut GetDataCommand| { &mut m.end_ms },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "wait",
                    |m: &GetDataCommand| { &m.wait },
                    |m: &mut GetDataCommand| { &mut m.wait },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDataCommand>(
                    "GetDataCommand",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDataCommand {
        static mut instance: ::protobuf::lazy::Lazy<GetDataCommand> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDataCommand,
        };
        unsafe {
            instance.get(GetDataCommand::new)
        }
    }
}

impl ::protobuf::Clear for GetDataCommand {
    fn clear(&mut self) {
        self.start_ms = 0;
        self.end_ms = 0;
        self.wait = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDataCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDataCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetMeasturementRateCommand {
    // message fields
    pub measurement_window_cycles: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetMeasturementRateCommand {
    fn default() -> &'a SetMeasturementRateCommand {
        <SetMeasturementRateCommand as ::protobuf::Message>::default_instance()
    }
}

impl SetMeasturementRateCommand {
    pub fn new() -> SetMeasturementRateCommand {
        ::std::default::Default::default()
    }

    // uint32 measurement_window_cycles = 1;


    pub fn get_measurement_window_cycles(&self) -> u32 {
        self.measurement_window_cycles
    }
    pub fn clear_measurement_window_cycles(&mut self) {
        self.measurement_window_cycles = 0;
    }

    // Param is passed by value, moved
    pub fn set_measurement_window_cycles(&mut self, v: u32) {
        self.measurement_window_cycles = v;
    }
}

impl ::protobuf::Message for SetMeasturementRateCommand {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.measurement_window_cycles = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.measurement_window_cycles != 0 {
            my_size += ::protobuf::rt::value_size(1, self.measurement_window_cycles, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.measurement_window_cycles != 0 {
            os.write_uint32(1, self.measurement_window_cycles)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetMeasturementRateCommand {
        SetMeasturementRateCommand::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "measurement_window_cycles",
                    |m: &SetMeasturementRateCommand| { &m.measurement_window_cycles },
                    |m: &mut SetMeasturementRateCommand| { &mut m.measurement_window_cycles },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetMeasturementRateCommand>(
                    "SetMeasturementRateCommand",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetMeasturementRateCommand {
        static mut instance: ::protobuf::lazy::Lazy<SetMeasturementRateCommand> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetMeasturementRateCommand,
        };
        unsafe {
            instance.get(SetMeasturementRateCommand::new)
        }
    }
}

impl ::protobuf::Clear for SetMeasturementRateCommand {
    fn clear(&mut self) {
        self.measurement_window_cycles = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetMeasturementRateCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetMeasturementRateCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendCommandToPlugin {
    // message fields
    pub plugin_name: ::std::string::String,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendCommandToPlugin {
    fn default() -> &'a SendCommandToPlugin {
        <SendCommandToPlugin as ::protobuf::Message>::default_instance()
    }
}

impl SendCommandToPlugin {
    pub fn new() -> SendCommandToPlugin {
        ::std::default::Default::default()
    }

    // string plugin_name = 1;


    pub fn get_plugin_name(&self) -> &str {
        &self.plugin_name
    }
    pub fn clear_plugin_name(&mut self) {
        self.plugin_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_plugin_name(&mut self, v: ::std::string::String) {
        self.plugin_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plugin_name(&mut self) -> &mut ::std::string::String {
        &mut self.plugin_name
    }

    // Take field
    pub fn take_plugin_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.plugin_name, ::std::string::String::new())
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SendCommandToPlugin {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.plugin_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.plugin_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.plugin_name);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.plugin_name.is_empty() {
            os.write_string(1, &self.plugin_name)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendCommandToPlugin {
        SendCommandToPlugin::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "plugin_name",
                    |m: &SendCommandToPlugin| { &m.plugin_name },
                    |m: &mut SendCommandToPlugin| { &mut m.plugin_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &SendCommandToPlugin| { &m.message },
                    |m: &mut SendCommandToPlugin| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendCommandToPlugin>(
                    "SendCommandToPlugin",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendCommandToPlugin {
        static mut instance: ::protobuf::lazy::Lazy<SendCommandToPlugin> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendCommandToPlugin,
        };
        unsafe {
            instance.get(SendCommandToPlugin::new)
        }
    }
}

impl ::protobuf::Clear for SendCommandToPlugin {
    fn clear(&mut self) {
        self.plugin_name.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendCommandToPlugin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendCommandToPlugin {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Command {
    // message fields
    pub seq: u32,
    pub box_id: i32,
    pub timestamp_ms: u64,
    pub identity: ::std::string::String,
    // message oneof groups
    pub command: ::std::option::Option<Command_oneof_command>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Command {
    fn default() -> &'a Command {
        <Command as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Command_oneof_command {
    info_command(GetInfoCommand),
    data_command(GetDataCommand),
    sampling_rate_command(SetMeasturementRateCommand),
    send_command_to_plugin(SendCommandToPlugin),
}

impl Command {
    pub fn new() -> Command {
        ::std::default::Default::default()
    }

    // uint32 seq = 1;


    pub fn get_seq(&self) -> u32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u32) {
        self.seq = v;
    }

    // int32 box_id = 2;


    pub fn get_box_id(&self) -> i32 {
        self.box_id
    }
    pub fn clear_box_id(&mut self) {
        self.box_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_box_id(&mut self, v: i32) {
        self.box_id = v;
    }

    // uint64 timestamp_ms = 3;


    pub fn get_timestamp_ms(&self) -> u64 {
        self.timestamp_ms
    }
    pub fn clear_timestamp_ms(&mut self) {
        self.timestamp_ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp_ms(&mut self, v: u64) {
        self.timestamp_ms = v;
    }

    // string identity = 4;


    pub fn get_identity(&self) -> &str {
        &self.identity
    }
    pub fn clear_identity(&mut self) {
        self.identity.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity(&mut self, v: ::std::string::String) {
        self.identity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity(&mut self) -> &mut ::std::string::String {
        &mut self.identity
    }

    // Take field
    pub fn take_identity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity, ::std::string::String::new())
    }

    // .opq.opqbox3.GetInfoCommand info_command = 5;


    pub fn get_info_command(&self) -> &GetInfoCommand {
        match self.command {
            ::std::option::Option::Some(Command_oneof_command::info_command(ref v)) => v,
            _ => GetInfoCommand::default_instance(),
        }
    }
    pub fn clear_info_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_info_command(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(Command_oneof_command::info_command(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_info_command(&mut self, v: GetInfoCommand) {
        self.command = ::std::option::Option::Some(Command_oneof_command::info_command(v))
    }

    // Mutable pointer to the field.
    pub fn mut_info_command(&mut self) -> &mut GetInfoCommand {
        if let ::std::option::Option::Some(Command_oneof_command::info_command(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(Command_oneof_command::info_command(GetInfoCommand::new()));
        }
        match self.command {
            ::std::option::Option::Some(Command_oneof_command::info_command(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_info_command(&mut self) -> GetInfoCommand {
        if self.has_info_command() {
            match self.command.take() {
                ::std::option::Option::Some(Command_oneof_command::info_command(v)) => v,
                _ => panic!(),
            }
        } else {
            GetInfoCommand::new()
        }
    }

    // .opq.opqbox3.GetDataCommand data_command = 6;


    pub fn get_data_command(&self) -> &GetDataCommand {
        match self.command {
            ::std::option::Option::Some(Command_oneof_command::data_command(ref v)) => v,
            _ => GetDataCommand::default_instance(),
        }
    }
    pub fn clear_data_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_data_command(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(Command_oneof_command::data_command(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_data_command(&mut self, v: GetDataCommand) {
        self.command = ::std::option::Option::Some(Command_oneof_command::data_command(v))
    }

    // Mutable pointer to the field.
    pub fn mut_data_command(&mut self) -> &mut GetDataCommand {
        if let ::std::option::Option::Some(Command_oneof_command::data_command(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(Command_oneof_command::data_command(GetDataCommand::new()));
        }
        match self.command {
            ::std::option::Option::Some(Command_oneof_command::data_command(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_data_command(&mut self) -> GetDataCommand {
        if self.has_data_command() {
            match self.command.take() {
                ::std::option::Option::Some(Command_oneof_command::data_command(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDataCommand::new()
        }
    }

    // .opq.opqbox3.SetMeasturementRateCommand sampling_rate_command = 7;


    pub fn get_sampling_rate_command(&self) -> &SetMeasturementRateCommand {
        match self.command {
            ::std::option::Option::Some(Command_oneof_command::sampling_rate_command(ref v)) => v,
            _ => SetMeasturementRateCommand::default_instance(),
        }
    }
    pub fn clear_sampling_rate_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_sampling_rate_command(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(Command_oneof_command::sampling_rate_command(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sampling_rate_command(&mut self, v: SetMeasturementRateCommand) {
        self.command = ::std::option::Option::Some(Command_oneof_command::sampling_rate_command(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sampling_rate_command(&mut self) -> &mut SetMeasturementRateCommand {
        if let ::std::option::Option::Some(Command_oneof_command::sampling_rate_command(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(Command_oneof_command::sampling_rate_command(SetMeasturementRateCommand::new()));
        }
        match self.command {
            ::std::option::Option::Some(Command_oneof_command::sampling_rate_command(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sampling_rate_command(&mut self) -> SetMeasturementRateCommand {
        if self.has_sampling_rate_command() {
            match self.command.take() {
                ::std::option::Option::Some(Command_oneof_command::sampling_rate_command(v)) => v,
                _ => panic!(),
            }
        } else {
            SetMeasturementRateCommand::new()
        }
    }

    // .opq.opqbox3.SendCommandToPlugin send_command_to_plugin = 8;


    pub fn get_send_command_to_plugin(&self) -> &SendCommandToPlugin {
        match self.command {
            ::std::option::Option::Some(Command_oneof_command::send_command_to_plugin(ref v)) => v,
            _ => SendCommandToPlugin::default_instance(),
        }
    }
    pub fn clear_send_command_to_plugin(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_send_command_to_plugin(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(Command_oneof_command::send_command_to_plugin(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_send_command_to_plugin(&mut self, v: SendCommandToPlugin) {
        self.command = ::std::option::Option::Some(Command_oneof_command::send_command_to_plugin(v))
    }

    // Mutable pointer to the field.
    pub fn mut_send_command_to_plugin(&mut self) -> &mut SendCommandToPlugin {
        if let ::std::option::Option::Some(Command_oneof_command::send_command_to_plugin(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(Command_oneof_command::send_command_to_plugin(SendCommandToPlugin::new()));
        }
        match self.command {
            ::std::option::Option::Some(Command_oneof_command::send_command_to_plugin(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_send_command_to_plugin(&mut self) -> SendCommandToPlugin {
        if self.has_send_command_to_plugin() {
            match self.command.take() {
                ::std::option::Option::Some(Command_oneof_command::send_command_to_plugin(v)) => v,
                _ => panic!(),
            }
        } else {
            SendCommandToPlugin::new()
        }
    }
}

impl ::protobuf::Message for Command {
    fn is_initialized(&self) -> bool {
        if let Some(Command_oneof_command::info_command(ref v)) = self.command {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Command_oneof_command::data_command(ref v)) = self.command {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Command_oneof_command::sampling_rate_command(ref v)) = self.command {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Command_oneof_command::send_command_to_plugin(ref v)) = self.command {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.box_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp_ms = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.command = ::std::option::Option::Some(Command_oneof_command::info_command(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.command = ::std::option::Option::Some(Command_oneof_command::data_command(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.command = ::std::option::Option::Some(Command_oneof_command::sampling_rate_command(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.command = ::std::option::Option::Some(Command_oneof_command::send_command_to_plugin(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(1, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.box_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.box_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp_ms != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timestamp_ms, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.identity.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.identity);
        }
        if let ::std::option::Option::Some(ref v) = self.command {
            match v {
                &Command_oneof_command::info_command(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Command_oneof_command::data_command(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Command_oneof_command::sampling_rate_command(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Command_oneof_command::send_command_to_plugin(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.seq != 0 {
            os.write_uint32(1, self.seq)?;
        }
        if self.box_id != 0 {
            os.write_int32(2, self.box_id)?;
        }
        if self.timestamp_ms != 0 {
            os.write_uint64(3, self.timestamp_ms)?;
        }
        if !self.identity.is_empty() {
            os.write_string(4, &self.identity)?;
        }
        if let ::std::option::Option::Some(ref v) = self.command {
            match v {
                &Command_oneof_command::info_command(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Command_oneof_command::data_command(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Command_oneof_command::sampling_rate_command(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Command_oneof_command::send_command_to_plugin(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Command {
        Command::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "seq",
                    |m: &Command| { &m.seq },
                    |m: &mut Command| { &mut m.seq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "box_id",
                    |m: &Command| { &m.box_id },
                    |m: &mut Command| { &mut m.box_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timestamp_ms",
                    |m: &Command| { &m.timestamp_ms },
                    |m: &mut Command| { &mut m.timestamp_ms },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "identity",
                    |m: &Command| { &m.identity },
                    |m: &mut Command| { &mut m.identity },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetInfoCommand>(
                    "info_command",
                    Command::has_info_command,
                    Command::get_info_command,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDataCommand>(
                    "data_command",
                    Command::has_data_command,
                    Command::get_data_command,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SetMeasturementRateCommand>(
                    "sampling_rate_command",
                    Command::has_sampling_rate_command,
                    Command::get_sampling_rate_command,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SendCommandToPlugin>(
                    "send_command_to_plugin",
                    Command::has_send_command_to_plugin,
                    Command::get_send_command_to_plugin,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Command>(
                    "Command",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Command {
        static mut instance: ::protobuf::lazy::Lazy<Command> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command,
        };
        unsafe {
            instance.get(Command::new)
        }
    }
}

impl ::protobuf::Clear for Command {
    fn clear(&mut self) {
        self.seq = 0;
        self.box_id = 0;
        self.timestamp_ms = 0;
        self.identity.clear();
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Command {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Command {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInfoResponse {
    // message fields
    pub mac_addr: ::std::string::String,
    pub wifi_network: ::std::string::String,
    pub ip: ::std::string::String,
    pub uptime: u64,
    pub calibration_constant: u64,
    pub pub_key: ::std::string::String,
    pub measurement_rate: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInfoResponse {
    fn default() -> &'a GetInfoResponse {
        <GetInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetInfoResponse {
    pub fn new() -> GetInfoResponse {
        ::std::default::Default::default()
    }

    // string mac_addr = 1;


    pub fn get_mac_addr(&self) -> &str {
        &self.mac_addr
    }
    pub fn clear_mac_addr(&mut self) {
        self.mac_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_mac_addr(&mut self, v: ::std::string::String) {
        self.mac_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mac_addr(&mut self) -> &mut ::std::string::String {
        &mut self.mac_addr
    }

    // Take field
    pub fn take_mac_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mac_addr, ::std::string::String::new())
    }

    // string wifi_network = 2;


    pub fn get_wifi_network(&self) -> &str {
        &self.wifi_network
    }
    pub fn clear_wifi_network(&mut self) {
        self.wifi_network.clear();
    }

    // Param is passed by value, moved
    pub fn set_wifi_network(&mut self, v: ::std::string::String) {
        self.wifi_network = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wifi_network(&mut self) -> &mut ::std::string::String {
        &mut self.wifi_network
    }

    // Take field
    pub fn take_wifi_network(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.wifi_network, ::std::string::String::new())
    }

    // string ip = 3;


    pub fn get_ip(&self) -> &str {
        &self.ip
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        &mut self.ip
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip, ::std::string::String::new())
    }

    // uint64 uptime = 4;


    pub fn get_uptime(&self) -> u64 {
        self.uptime
    }
    pub fn clear_uptime(&mut self) {
        self.uptime = 0;
    }

    // Param is passed by value, moved
    pub fn set_uptime(&mut self, v: u64) {
        self.uptime = v;
    }

    // uint64 calibration_constant = 5;


    pub fn get_calibration_constant(&self) -> u64 {
        self.calibration_constant
    }
    pub fn clear_calibration_constant(&mut self) {
        self.calibration_constant = 0;
    }

    // Param is passed by value, moved
    pub fn set_calibration_constant(&mut self, v: u64) {
        self.calibration_constant = v;
    }

    // string pub_key = 6;


    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    // uint32 measurement_rate = 7;


    pub fn get_measurement_rate(&self) -> u32 {
        self.measurement_rate
    }
    pub fn clear_measurement_rate(&mut self) {
        self.measurement_rate = 0;
    }

    // Param is passed by value, moved
    pub fn set_measurement_rate(&mut self, v: u32) {
        self.measurement_rate = v;
    }
}

impl ::protobuf::Message for GetInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mac_addr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.wifi_network)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.uptime = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.calibration_constant = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.measurement_rate = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mac_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.mac_addr);
        }
        if !self.wifi_network.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.wifi_network);
        }
        if !self.ip.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ip);
        }
        if self.uptime != 0 {
            my_size += ::protobuf::rt::value_size(4, self.uptime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.calibration_constant != 0 {
            my_size += ::protobuf::rt::value_size(5, self.calibration_constant, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.pub_key);
        }
        if self.measurement_rate != 0 {
            my_size += ::protobuf::rt::value_size(7, self.measurement_rate, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.mac_addr.is_empty() {
            os.write_string(1, &self.mac_addr)?;
        }
        if !self.wifi_network.is_empty() {
            os.write_string(2, &self.wifi_network)?;
        }
        if !self.ip.is_empty() {
            os.write_string(3, &self.ip)?;
        }
        if self.uptime != 0 {
            os.write_uint64(4, self.uptime)?;
        }
        if self.calibration_constant != 0 {
            os.write_uint64(5, self.calibration_constant)?;
        }
        if !self.pub_key.is_empty() {
            os.write_string(6, &self.pub_key)?;
        }
        if self.measurement_rate != 0 {
            os.write_uint32(7, self.measurement_rate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInfoResponse {
        GetInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mac_addr",
                    |m: &GetInfoResponse| { &m.mac_addr },
                    |m: &mut GetInfoResponse| { &mut m.mac_addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "wifi_network",
                    |m: &GetInfoResponse| { &m.wifi_network },
                    |m: &mut GetInfoResponse| { &mut m.wifi_network },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip",
                    |m: &GetInfoResponse| { &m.ip },
                    |m: &mut GetInfoResponse| { &mut m.ip },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "uptime",
                    |m: &GetInfoResponse| { &m.uptime },
                    |m: &mut GetInfoResponse| { &mut m.uptime },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "calibration_constant",
                    |m: &GetInfoResponse| { &m.calibration_constant },
                    |m: &mut GetInfoResponse| { &mut m.calibration_constant },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pub_key",
                    |m: &GetInfoResponse| { &m.pub_key },
                    |m: &mut GetInfoResponse| { &mut m.pub_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "measurement_rate",
                    |m: &GetInfoResponse| { &m.measurement_rate },
                    |m: &mut GetInfoResponse| { &mut m.measurement_rate },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetInfoResponse>(
                    "GetInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetInfoResponse,
        };
        unsafe {
            instance.get(GetInfoResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetInfoResponse {
    fn clear(&mut self) {
        self.mac_addr.clear();
        self.wifi_network.clear();
        self.ip.clear();
        self.uptime = 0;
        self.calibration_constant = 0;
        self.pub_key.clear();
        self.measurement_rate = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetMeasurementRateResponse {
    // message fields
    pub old_rate_cycles: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetMeasurementRateResponse {
    fn default() -> &'a SetMeasurementRateResponse {
        <SetMeasurementRateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetMeasurementRateResponse {
    pub fn new() -> SetMeasurementRateResponse {
        ::std::default::Default::default()
    }

    // uint32 old_rate_cycles = 1;


    pub fn get_old_rate_cycles(&self) -> u32 {
        self.old_rate_cycles
    }
    pub fn clear_old_rate_cycles(&mut self) {
        self.old_rate_cycles = 0;
    }

    // Param is passed by value, moved
    pub fn set_old_rate_cycles(&mut self, v: u32) {
        self.old_rate_cycles = v;
    }
}

impl ::protobuf::Message for SetMeasurementRateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.old_rate_cycles = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.old_rate_cycles != 0 {
            my_size += ::protobuf::rt::value_size(1, self.old_rate_cycles, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.old_rate_cycles != 0 {
            os.write_uint32(1, self.old_rate_cycles)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetMeasurementRateResponse {
        SetMeasurementRateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "old_rate_cycles",
                    |m: &SetMeasurementRateResponse| { &m.old_rate_cycles },
                    |m: &mut SetMeasurementRateResponse| { &mut m.old_rate_cycles },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetMeasurementRateResponse>(
                    "SetMeasurementRateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetMeasurementRateResponse {
        static mut instance: ::protobuf::lazy::Lazy<SetMeasurementRateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetMeasurementRateResponse,
        };
        unsafe {
            instance.get(SetMeasurementRateResponse::new)
        }
    }
}

impl ::protobuf::Clear for SetMeasurementRateResponse {
    fn clear(&mut self) {
        self.old_rate_cycles = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetMeasurementRateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetMeasurementRateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDataResponseHeader {
    // message fields
    pub start_ts: u64,
    pub end_ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDataResponseHeader {
    fn default() -> &'a GetDataResponseHeader {
        <GetDataResponseHeader as ::protobuf::Message>::default_instance()
    }
}

impl GetDataResponseHeader {
    pub fn new() -> GetDataResponseHeader {
        ::std::default::Default::default()
    }

    // uint64 start_ts = 1;


    pub fn get_start_ts(&self) -> u64 {
        self.start_ts
    }
    pub fn clear_start_ts(&mut self) {
        self.start_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_ts(&mut self, v: u64) {
        self.start_ts = v;
    }

    // uint64 end_ts = 2;


    pub fn get_end_ts(&self) -> u64 {
        self.end_ts
    }
    pub fn clear_end_ts(&mut self) {
        self.end_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_ts(&mut self, v: u64) {
        self.end_ts = v;
    }
}

impl ::protobuf::Message for GetDataResponseHeader {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_ts = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.end_ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_ts != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_ts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.end_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.start_ts != 0 {
            os.write_uint64(1, self.start_ts)?;
        }
        if self.end_ts != 0 {
            os.write_uint64(2, self.end_ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDataResponseHeader {
        GetDataResponseHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "start_ts",
                    |m: &GetDataResponseHeader| { &m.start_ts },
                    |m: &mut GetDataResponseHeader| { &mut m.start_ts },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "end_ts",
                    |m: &GetDataResponseHeader| { &m.end_ts },
                    |m: &mut GetDataResponseHeader| { &mut m.end_ts },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDataResponseHeader>(
                    "GetDataResponseHeader",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDataResponseHeader {
        static mut instance: ::protobuf::lazy::Lazy<GetDataResponseHeader> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDataResponseHeader,
        };
        unsafe {
            instance.get(GetDataResponseHeader::new)
        }
    }
}

impl ::protobuf::Clear for GetDataResponseHeader {
    fn clear(&mut self) {
        self.start_ts = 0;
        self.end_ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDataResponseHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDataResponseHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendCommandToPluginResponse {
    // message fields
    pub ok: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendCommandToPluginResponse {
    fn default() -> &'a SendCommandToPluginResponse {
        <SendCommandToPluginResponse as ::protobuf::Message>::default_instance()
    }
}

impl SendCommandToPluginResponse {
    pub fn new() -> SendCommandToPluginResponse {
        ::std::default::Default::default()
    }

    // bool ok = 1;


    pub fn get_ok(&self) -> bool {
        self.ok
    }
    pub fn clear_ok(&mut self) {
        self.ok = false;
    }

    // Param is passed by value, moved
    pub fn set_ok(&mut self, v: bool) {
        self.ok = v;
    }
}

impl ::protobuf::Message for SendCommandToPluginResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ok = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ok != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.ok != false {
            os.write_bool(1, self.ok)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendCommandToPluginResponse {
        SendCommandToPluginResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ok",
                    |m: &SendCommandToPluginResponse| { &m.ok },
                    |m: &mut SendCommandToPluginResponse| { &mut m.ok },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendCommandToPluginResponse>(
                    "SendCommandToPluginResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendCommandToPluginResponse {
        static mut instance: ::protobuf::lazy::Lazy<SendCommandToPluginResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendCommandToPluginResponse,
        };
        unsafe {
            instance.get(SendCommandToPluginResponse::new)
        }
    }
}

impl ::protobuf::Clear for SendCommandToPluginResponse {
    fn clear(&mut self) {
        self.ok = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendCommandToPluginResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendCommandToPluginResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response {
    // message fields
    pub box_id: i32,
    pub seq: u32,
    pub timestamp_ms: u64,
    // message oneof groups
    pub response: ::std::option::Option<Response_oneof_response>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response {
    fn default() -> &'a Response {
        <Response as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Response_oneof_response {
    info_response(GetInfoResponse),
    message_rate_reponse(SetMeasurementRateResponse),
    get_data_response(GetDataResponseHeader),
    command_to_plugin_response(SendCommandToPluginResponse),
}

impl Response {
    pub fn new() -> Response {
        ::std::default::Default::default()
    }

    // int32 box_id = 1;


    pub fn get_box_id(&self) -> i32 {
        self.box_id
    }
    pub fn clear_box_id(&mut self) {
        self.box_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_box_id(&mut self, v: i32) {
        self.box_id = v;
    }

    // uint32 seq = 2;


    pub fn get_seq(&self) -> u32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u32) {
        self.seq = v;
    }

    // uint64 timestamp_ms = 3;


    pub fn get_timestamp_ms(&self) -> u64 {
        self.timestamp_ms
    }
    pub fn clear_timestamp_ms(&mut self) {
        self.timestamp_ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp_ms(&mut self, v: u64) {
        self.timestamp_ms = v;
    }

    // .opq.opqbox3.GetInfoResponse info_response = 4;


    pub fn get_info_response(&self) -> &GetInfoResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::info_response(ref v)) => v,
            _ => GetInfoResponse::default_instance(),
        }
    }
    pub fn clear_info_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_info_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::info_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_info_response(&mut self, v: GetInfoResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::info_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_info_response(&mut self) -> &mut GetInfoResponse {
        if let ::std::option::Option::Some(Response_oneof_response::info_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::info_response(GetInfoResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::info_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_info_response(&mut self) -> GetInfoResponse {
        if self.has_info_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::info_response(v)) => v,
                _ => panic!(),
            }
        } else {
            GetInfoResponse::new()
        }
    }

    // .opq.opqbox3.SetMeasurementRateResponse message_rate_reponse = 5;


    pub fn get_message_rate_reponse(&self) -> &SetMeasurementRateResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::message_rate_reponse(ref v)) => v,
            _ => SetMeasurementRateResponse::default_instance(),
        }
    }
    pub fn clear_message_rate_reponse(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_message_rate_reponse(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::message_rate_reponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_message_rate_reponse(&mut self, v: SetMeasurementRateResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::message_rate_reponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_message_rate_reponse(&mut self) -> &mut SetMeasurementRateResponse {
        if let ::std::option::Option::Some(Response_oneof_response::message_rate_reponse(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::message_rate_reponse(SetMeasurementRateResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::message_rate_reponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_message_rate_reponse(&mut self) -> SetMeasurementRateResponse {
        if self.has_message_rate_reponse() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::message_rate_reponse(v)) => v,
                _ => panic!(),
            }
        } else {
            SetMeasurementRateResponse::new()
        }
    }

    // .opq.opqbox3.GetDataResponseHeader get_data_response = 6;


    pub fn get_get_data_response(&self) -> &GetDataResponseHeader {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::get_data_response(ref v)) => v,
            _ => GetDataResponseHeader::default_instance(),
        }
    }
    pub fn clear_get_data_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_get_data_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::get_data_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_data_response(&mut self, v: GetDataResponseHeader) {
        self.response = ::std::option::Option::Some(Response_oneof_response::get_data_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_data_response(&mut self) -> &mut GetDataResponseHeader {
        if let ::std::option::Option::Some(Response_oneof_response::get_data_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::get_data_response(GetDataResponseHeader::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::get_data_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_data_response(&mut self) -> GetDataResponseHeader {
        if self.has_get_data_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::get_data_response(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDataResponseHeader::new()
        }
    }

    // .opq.opqbox3.SendCommandToPluginResponse command_to_plugin_response = 7;


    pub fn get_command_to_plugin_response(&self) -> &SendCommandToPluginResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::command_to_plugin_response(ref v)) => v,
            _ => SendCommandToPluginResponse::default_instance(),
        }
    }
    pub fn clear_command_to_plugin_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_command_to_plugin_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::command_to_plugin_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_command_to_plugin_response(&mut self, v: SendCommandToPluginResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::command_to_plugin_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_command_to_plugin_response(&mut self) -> &mut SendCommandToPluginResponse {
        if let ::std::option::Option::Some(Response_oneof_response::command_to_plugin_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::command_to_plugin_response(SendCommandToPluginResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::command_to_plugin_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_command_to_plugin_response(&mut self) -> SendCommandToPluginResponse {
        if self.has_command_to_plugin_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::command_to_plugin_response(v)) => v,
                _ => panic!(),
            }
        } else {
            SendCommandToPluginResponse::new()
        }
    }
}

impl ::protobuf::Message for Response {
    fn is_initialized(&self) -> bool {
        if let Some(Response_oneof_response::info_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::message_rate_reponse(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::get_data_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::command_to_plugin_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.box_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp_ms = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::info_response(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::message_rate_reponse(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::get_data_response(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::command_to_plugin_response(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.box_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.box_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(2, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp_ms != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timestamp_ms, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &Response_oneof_response::info_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::message_rate_reponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::get_data_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::command_to_plugin_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.box_id != 0 {
            os.write_int32(1, self.box_id)?;
        }
        if self.seq != 0 {
            os.write_uint32(2, self.seq)?;
        }
        if self.timestamp_ms != 0 {
            os.write_uint64(3, self.timestamp_ms)?;
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &Response_oneof_response::info_response(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::message_rate_reponse(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::get_data_response(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::command_to_plugin_response(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response {
        Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "box_id",
                    |m: &Response| { &m.box_id },
                    |m: &mut Response| { &mut m.box_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "seq",
                    |m: &Response| { &m.seq },
                    |m: &mut Response| { &mut m.seq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timestamp_ms",
                    |m: &Response| { &m.timestamp_ms },
                    |m: &mut Response| { &mut m.timestamp_ms },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetInfoResponse>(
                    "info_response",
                    Response::has_info_response,
                    Response::get_info_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SetMeasurementRateResponse>(
                    "message_rate_reponse",
                    Response::has_message_rate_reponse,
                    Response::get_message_rate_reponse,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDataResponseHeader>(
                    "get_data_response",
                    Response::has_get_data_response,
                    Response::get_get_data_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SendCommandToPluginResponse>(
                    "command_to_plugin_response",
                    Response::has_command_to_plugin_response,
                    Response::get_command_to_plugin_response,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Response>(
                    "Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Response {
        static mut instance: ::protobuf::lazy::Lazy<Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Response,
        };
        unsafe {
            instance.get(Response::new)
        }
    }
}

impl ::protobuf::Clear for Response {
    fn clear(&mut self) {
        self.box_id = 0;
        self.seq = 0;
        self.timestamp_ms = 0;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Cycle {
    // message fields
    pub datapoints: ::std::vec::Vec<i32>,
    pub timestamp_ms: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cycle {
    fn default() -> &'a Cycle {
        <Cycle as ::protobuf::Message>::default_instance()
    }
}

impl Cycle {
    pub fn new() -> Cycle {
        ::std::default::Default::default()
    }

    // repeated int32 datapoints = 1;


    pub fn get_datapoints(&self) -> &[i32] {
        &self.datapoints
    }
    pub fn clear_datapoints(&mut self) {
        self.datapoints.clear();
    }

    // Param is passed by value, moved
    pub fn set_datapoints(&mut self, v: ::std::vec::Vec<i32>) {
        self.datapoints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_datapoints(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.datapoints
    }

    // Take field
    pub fn take_datapoints(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.datapoints, ::std::vec::Vec::new())
    }

    // uint64 timestamp_ms = 2;


    pub fn get_timestamp_ms(&self) -> u64 {
        self.timestamp_ms
    }
    pub fn clear_timestamp_ms(&mut self) {
        self.timestamp_ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp_ms(&mut self, v: u64) {
        self.timestamp_ms = v;
    }
}

impl ::protobuf::Message for Cycle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.datapoints)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp_ms = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.datapoints {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.timestamp_ms != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timestamp_ms, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.datapoints {
            os.write_int32(1, *v)?;
        };
        if self.timestamp_ms != 0 {
            os.write_uint64(2, self.timestamp_ms)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cycle {
        Cycle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "datapoints",
                    |m: &Cycle| { &m.datapoints },
                    |m: &mut Cycle| { &mut m.datapoints },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timestamp_ms",
                    |m: &Cycle| { &m.timestamp_ms },
                    |m: &mut Cycle| { &mut m.timestamp_ms },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Cycle>(
                    "Cycle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Cycle {
        static mut instance: ::protobuf::lazy::Lazy<Cycle> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Cycle,
        };
        unsafe {
            instance.get(Cycle::new)
        }
    }
}

impl ::protobuf::Clear for Cycle {
    fn clear(&mut self) {
        self.datapoints.clear();
        self.timestamp_ms = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cycle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cycle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\ropqbox3.proto\x12\x0bopq.opqbox3\x1a\x0frustproto.proto\"F\n\x06Metr\
    ic\x12\x10\n\x03min\x18\x01\x20\x01(\x02R\x03min\x12\x10\n\x03max\x18\
    \x02\x20\x01(\x02R\x03max\x12\x18\n\x07average\x18\x03\x20\x01(\x02R\x07\
    average\"\xd9\x01\n\x0bMeasurement\x12\x15\n\x06box_id\x18\x01\x20\x01(\
    \rR\x05boxId\x12!\n\x0ctimestamp_ms\x18\x02\x20\x01(\x04R\x0btimestampMs\
    \x12?\n\x07metrics\x18\x03\x20\x03(\x0b2%.opq.opqbox3.Measurement.Metric\
    sEntryR\x07metrics\x1aO\n\x0cMetricsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12)\n\x05value\x18\x02\x20\x01(\x0b2\x13.opq.opqbox3.Me\
    tricR\x05value:\x028\x01\"\x10\n\x0eGetInfoCommand\"V\n\x0eGetDataComman\
    d\x12\x19\n\x08start_ms\x18\x01\x20\x01(\x04R\x07startMs\x12\x15\n\x06en\
    d_ms\x18\x02\x20\x01(\x04R\x05endMs\x12\x12\n\x04wait\x18\x03\x20\x01(\
    \x08R\x04wait\"X\n\x1aSetMeasturementRateCommand\x12:\n\x19measurement_w\
    indow_cycles\x18\x01\x20\x01(\rR\x17measurementWindowCycles\"P\n\x13Send\
    CommandToPlugin\x12\x1f\n\x0bplugin_name\x18\x01\x20\x01(\tR\npluginName\
    \x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"\xb8\x03\n\x07Comm\
    and\x12\x10\n\x03seq\x18\x01\x20\x01(\rR\x03seq\x12\x15\n\x06box_id\x18\
    \x02\x20\x01(\x05R\x05boxId\x12!\n\x0ctimestamp_ms\x18\x03\x20\x01(\x04R\
    \x0btimestampMs\x12\x1a\n\x08identity\x18\x04\x20\x01(\tR\x08identity\
    \x12@\n\x0cinfo_command\x18\x05\x20\x01(\x0b2\x1b.opq.opqbox3.GetInfoCom\
    mandH\0R\x0binfoCommand\x12@\n\x0cdata_command\x18\x06\x20\x01(\x0b2\x1b\
    .opq.opqbox3.GetDataCommandH\0R\x0bdataCommand\x12]\n\x15sampling_rate_c\
    ommand\x18\x07\x20\x01(\x0b2'.opq.opqbox3.SetMeasturementRateCommandH\0R\
    \x13samplingRateCommand\x12W\n\x16send_command_to_plugin\x18\x08\x20\x01\
    (\x0b2\x20.opq.opqbox3.SendCommandToPluginH\0R\x13sendCommandToPluginB\t\
    \n\x07command\"\xee\x01\n\x0fGetInfoResponse\x12\x19\n\x08mac_addr\x18\
    \x01\x20\x01(\tR\x07macAddr\x12!\n\x0cwifi_network\x18\x02\x20\x01(\tR\
    \x0bwifiNetwork\x12\x0e\n\x02ip\x18\x03\x20\x01(\tR\x02ip\x12\x16\n\x06u\
    ptime\x18\x04\x20\x01(\x04R\x06uptime\x121\n\x14calibration_constant\x18\
    \x05\x20\x01(\x04R\x13calibrationConstant\x12\x17\n\x07pub_key\x18\x06\
    \x20\x01(\tR\x06pubKey\x12)\n\x10measurement_rate\x18\x07\x20\x01(\rR\
    \x0fmeasurementRate\"D\n\x1aSetMeasurementRateResponse\x12&\n\x0fold_rat\
    e_cycles\x18\x01\x20\x01(\rR\roldRateCycles\"I\n\x15GetDataResponseHeade\
    r\x12\x19\n\x08start_ts\x18\x01\x20\x01(\x04R\x07startTs\x12\x15\n\x06en\
    d_ts\x18\x02\x20\x01(\x04R\x05endTs\"-\n\x1bSendCommandToPluginResponse\
    \x12\x0e\n\x02ok\x18\x01\x20\x01(\x08R\x02ok\"\xbf\x03\n\x08Response\x12\
    \x15\n\x06box_id\x18\x01\x20\x01(\x05R\x05boxId\x12\x10\n\x03seq\x18\x02\
    \x20\x01(\rR\x03seq\x12!\n\x0ctimestamp_ms\x18\x03\x20\x01(\x04R\x0btime\
    stampMs\x12C\n\rinfo_response\x18\x04\x20\x01(\x0b2\x1c.opq.opqbox3.GetI\
    nfoResponseH\0R\x0cinfoResponse\x12[\n\x14message_rate_reponse\x18\x05\
    \x20\x01(\x0b2'.opq.opqbox3.SetMeasurementRateResponseH\0R\x12messageRat\
    eReponse\x12P\n\x11get_data_response\x18\x06\x20\x01(\x0b2\".opq.opqbox3\
    .GetDataResponseHeaderH\0R\x0fgetDataResponse\x12g\n\x1acommand_to_plugi\
    n_response\x18\x07\x20\x01(\x0b2(.opq.opqbox3.SendCommandToPluginRespons\
    eH\0R\x17commandToPluginResponseB\n\n\x08response\"J\n\x05Cycle\x12\x1e\
    \n\ndatapoints\x18\x01\x20\x03(\x05R\ndatapoints\x12!\n\x0ctimestamp_ms\
    \x18\x02\x20\x01(\x04R\x0btimestampMsB\x04\xc8\xa6\x08\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
